# Intro, Chapters 1 and 2

## Intro and Chapter 1

* Originally C with classes, extended from C by Bjarne Stroustrup
* Consistently one of the top 5 languages
* Lots of applications
* Distinct parts:
  * C language
  * C preprocessor
  * Classes and objects
  * Templates
  * Standard Template Library - common functionality
* First standard: C++98, followed up with C++03 bugfix
* Then C++11 in 2011, C++14 in 2014 (e.g. lambdas), C++17 in 2017
* This course is C++14, as C++17 not universally supported
* All of this course is designed for CLI execution; can be compiled on Linux, Mac, Windows using XCode, MS VisualC++, etc.
* Xcode uses clang from LLVM project, a modern and complete C++ compiler
* I was able to build and run the C++11 example on Linux and Mac OS easily.
* It looks like Bazel uses the default toolchain on your system without configuration, which makes life easy, but you can override if you want to.

## Chapter 2

Basic syntax and anatomy of a C++ program

* Statement: line, terminated with ;
* Function: larger unit of code, may contain statements and expressions, often designed to be reused.
* Main function: main entrypoint of any program, called by OS when program launches.
* Variable holds value (or values) for later use.  Must be declared before use.
* Single line comment follows //
* /* multi-line comment */
* `int main()`: returns an int.  In this case, exit code. 0 == success.
* `int main(int argc, char **argv)`: count of args, array of strings representing args.  Now optional, originally mandatory.
* Function code included in {}
* Whitespace mostly ignored in C/C++.  Just included for human benefit.
* `std::puts()`: put string to console.
* `std::printf()`: does the same thing.
* `iostream::cout`: ditto.  Many ways to skin a cat.
* `#include <cstdio>`: not a C++ statement, a directive to "preprocessor".  Replaces that line of text with the entire contents of file (C standard I/O library).
* `using namespace std;`: put this file inside the `std` namespace, which is where the standard library lives.

Statements and expressions

* Statement: ends with a semicolon
* Expression: returns a value (even if not used)
* `std::printf()` uses the same %d, %s directives etc. as Go
* Note that `x = 42` (the assignment statement) is also an expression, and implicitly returns x (i.e., with value 42).  So you can e.g. do `int x; printf("Hello %d", x = 42);`.  This is similar to Perl.

Identifiers

* Readable names for things
* Can only consist of [A-Za-z0-9_]: note no `-` or `.`
* May not begin with a numeral or conflict with reserved words/tokens
* Case sensitive
* Non-latin characters are implementation dependent and not portable
* Any length, but only 63 chars are guaranteed to be checked to be uniqueness
* Keep less than 31 long if exported
* `_` begins private identifiers
* `__` system use only
* Use consistent case
* Variables are strongly typed
* Undefined variables are "dangerous" (ooh, spooky!): looks like they throw an error, but still compile OK
* Can declare type and initialize in one step in many circumstances like in other typed languages, e.g. `int i = 42;`
* Usually best to initialize straight away
* Qualifier becomes part of type: e.g. `const int i = 7;`: a "read only variable" that compiler prevents from being overwritten.  Not just an `int`, but a `const int`.

Pointers

* Powerful, useful, common, dangerous
* Recall a Variable is a typed and named location in memory
* `int x = 4; int y = x;` first declares a variable `x` with a value 4, then declares a new variable `y` and copies the value from x into it.  These two variables are completely independent from that point onwards.
* `int *ip;` declares an integer pointer, which is a special type, containing a pointer to an integer existing at a different point in memory.  Note that confusingly the star is on the variable name, not the type name.
* `ip = &x;` points ip to the "address of" x.  Same as in Go.
* `y = *ip;` dereferences ip, i.e. reads through the pointer, and copies the actual value to y.  Again, same as in Go.
* If you try and print a pointer, you'll get (some representation of) the address in memory.

References
